function DHL = Read_UIH_DHL(fid)
% % //           ScanStart      Halt         VSM Trigger         
% % //           s              h            v                   h         v
% % //           |______________||||||||||||||___________________|||||||||||_______
% % ///                                                 ____
% % //       ADC ______________________________________|    |______________________
% % //
% % // ScanTimer |<----------------------------------->|
% % //           0++ ..............................................................
% % //
% % // VsmTimer                              |<------->|
% % //           0++.........................0++............................0++....
% % //
% % // GcCounter 0++............==...........++..................==.........++.....


% 
% typedef struct
% {
%    // type      name              pack option   (off:size)  Set by, Comments
%    float        m_aflPosition[3]     __PACK__;  //( 0:12)   SEQ     slice position, 0:sag,1:cor,2:tra
%    float        m_aflOrientation[4]  __PACK__;  //(12:16)   SEQ     slice orientation,0:sag,1:cor,2:tra (Normal Vector),3:inplane_rotate_angle (degree)
% } SSliceInfo;                                   //Total:28 Bytes
% 
% //////////////////////////////////////////////////////////////////////////////////////////////////////
% ///		Definition for IRIP parameters
% //////////////////////////////////////////////////////////////////////////////////////////////////////
% ///     
% ///     48 Bytes are reserved for IRIP parameters. A union (IripPara) was defined to
% ///		store int16, int32, float and double flexibly. 
% ///     The application developer should appoint which type of data to use between sequence and IRIP. 
% /// 
% //////////////////////////////////////////////////////////////////////////////////////////////////////
% 
% 
% typedef struct
% {
%    // type      name              pack option   (off:size)  Set by, Comments
%    SMiniDHL     m_myMiniDHL                 ;   //(0:48)            mini DHL data structure. 
%    uint64_t     m_ullCtrlFlags      __PACK__;   //(48:8)    SEQ&RT  sequence control flags (DHL_ACQUISITION_END flag set by RT)
%    SLoopControlIndex m_myLCI                ;   //(56:32)   SEQ     sequence loop control index
%    uint16_t     m_ushCutoffHead     __PACK__;   //(88:2)    SEQ     data need to be cut off in an acquisition line, in head direction
%    uint16_t     m_ushCutoffTail     __PACK__;   //(90:2)    SEQ     data need to be cut off in an acquisition line, in tail direction
%    uint16_t     m_ushROCenter       __PACK__;   //(92:2)    SEQ     kspace center index of readout  
%    uint16_t     m_ushPECenter       __PACK__;   //(94:2)    SEQ     kspace center index of phase encoding
%    uint16_t     m_ushSPECenter      __PACK__;   //(96:2)    SEQ     kspace center index of secondary phase encoding
%    SSliceInfo   m_mySliceInfo               ;   //(98:28)   SEQ     slice position and orientation 
%    IripPara     
%      m_aIripPara[DHL_IRIPPARA_SIZE] __PACK__;   //(126:48)  SEQ     parameters for IRIP
%    uint16_t     m_ushReserved[7]    __PACK__;   //(174:14)  N.A     make align to 192 bytes, reserved, DO NOT USE NOW
%    uint32_t     m_ulCRC             __PACK__;   //(188:4)   N.A     CRC check (not implement in s1)
% }SDHL;                                          //Total:192 Bytes

%%%%%%%%%%%%%m_myMiniDHL
b                    = 0;
%     uint8_t    m_ucVersion          __PACK__;   //( 0:1)    DHL     DHL version, checked by DRXU
%     uint8_t    m_ucReserved[3]      __PACK__;   //( 1:3)    N.A     reserved, DO NOT USE NOW
DHL.m_ucVersion = fread(fid,1,'uint8'); b = b + 1;
% uint8_t    m_uRFSettingIndex    __PACK__;   //( 1:1)    RTCtrl  COCO Setting index
fseek(fid,1,'cof');b = b + 1;
% uint8_t    m_uReceiveGain       __PACK__;   //( 2:1)    RTCtrl  ADC high/low gain
DHL.m_uReceiveGain = fread(fid,1,'uint8');b = b + 1;   %0:high gain;1:low gain
% uint8_t    m_ucReserved         __PACK__;   //( 3:1)    N.A     reserved, DO NOT USE NOW
fseek(fid,1,'cof'); b = b + 1;
%     uint32_t   m_ulDataLength       __PACK__;   //( 4:4)    DRXU    data length = sizeof(DHL) + m_ushUsedChannels * sizeof(line data)
DHL.m_ulDataLength = fread(fid,1,'uint32');b = b + 4;
%     uint64_t   m_ullMeasUID         __PACK__;   //( 8:8)    RTCtrl  measurement UID, generated by MeasCtrl, get from Uprotocol
DHL.m_ullMeasUID = fread(fid,1,'uint64');b = b + 8;
%     uint32_t   m_ulSysTimeStamp     __PACK__;   //(16:4)    ACQ     absolute system time(ms) of the MCIR, range 24 hour, (maximum 49.7days for uint32_t)
DHL.m_ulSysTimeStamp = fread(fid,1,'uint32');b = b + 4;
%     uint32_t   m_ulScanTimeStamp    __PACK__;   //(20:4)    SCTU    the ScanTimer starting from 0 of each scan(ms), see above
DHL.m_ulScanTimeStamp = fread(fid,1,'uint32');b = b + 4;
%     uint32_t   m_ulVSMTimeStamp     __PACK__;   //(24:4)    STCU    the VsmTimer starting from last VSM trigger(ms), see above 
DHL.m_ulVSMTimeStamp = fread(fid,1,'uint32');b = b + 4;
%     int32_t    m_lTabPositionX      __PACK__;   //(28:4)    N.A     absolute table position in x direction, unit: 0.1 mm
DHL.m_lTabPositionX = fread(fid,1,'int32');b = b + 4;
%     int32_t    m_lTabPositionY      __PACK__;   //(32:4)    N.A     absolute table position in y direction, unit: 0.1 mm
DHL.m_lTabPositionY = fread(fid,1,'int32');b = b + 4;
%     int32_t    m_lTabPositionZ      __PACK__;   //(36:4)    RTCtrl  absolute table position in z direction, unit: 0.1 mm, set by RT controller
DHL.m_lTabPositionZ = fread(fid,1,'int32');b = b + 4;
%     uint16_t   m_ushSamples         __PACK__;   //(40:2)    RTCtrl  acquisition samples in one channel(dhl_samples = pADC->GetSamples()*RO_OverSamplingFactor)
DHL.m_ushSamples = fread(fid,1,'uint16');b = b + 2;
%     uint16_t   m_ushUsedChannels    __PACK__;   //(42:2)    RTCtrl  used channel for an acquisition
DHL.m_ushUsedChannels = fread(fid,1,'uint16');b = b + 2;

    
%     uint32_t   m_ulReserverd        __PACK__;   //(44:4)    N.A     reserved, DO NOT USE NOW
fseek(fid,4,'cof');              b = b + 4;
%%%%%m_ullCtrlFlags
% uint64_t     m_ullCtrlFlags      __PACK__;   //(48:8)    SEQ&RT  sequence control flags (DHL_ACQUISITION_END flag set by RT)
DHL.m_ullCtrlFlags = fread(fid,1,'uint64');b = b + 8;

%%%%%
% #define NUMBER_OF_USER_LCI           (5)
%     uint16_t    m_ushRepeat         __PACK__;   //( 0:2)    SEQ     Index of scan(repeat scan)
DHL.m_ushRepeat = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushCardiacPhase   __PACK__;   //( 2:2)    SEQ     Index of cardiac phase
DHL.m_ushCardiacPhase = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushSlice          __PACK__;   //( 4:2)    SEQ     Index of slice
DHL.m_ushSlice = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushAverage        __PACK__;   //( 6:2)    SEQ     Index of acquisition for average
DHL.m_ushAverage = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushContrast       __PACK__;   //( 8:2)    SEQ     Index of contrast for multi-TE
DHL.m_ushContrast = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushSet            __PACK__;   //(10:2)    SEQ     Index of multi-data set for application such as dixon, multi-echo combine etc.
DHL.m_ushSet = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushShot           __PACK__;   //(12:2)    SEQ     Index of shot
DHL.m_ushShot = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushSegment        __PACK__;   //(14:2)    SEQ     Index of segment
DHL.m_ushSegment = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushPELine         __PACK__;   //(16:2)    SEQ     Index of PE line
DHL.m_ushPELine = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushSPELine        __PACK__;   //(18:2)    SEQ     Index of SPE line
DHL.m_ushSPELine = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    m_ushUserCtrlFlag   __PACK__;   //(20:2)    SEQ     16 user defined control flags for applications
DHL.m_ushUserCtrlFlag = fread(fid,1,'uint16');b = b + 2;
%     uint16_t    
%      m_ushUser[NUMBER_OF_USER_LCI] __PACK__;    //(22:10)   SEQ     5 user defined indexes for applications
DHL.m_ushUser = fread(fid,[1,5],'uint16');  b = b + 10;

%%%%%%%%%%%%%%%%%%%%
%    uint16_t     m_ushCutoffHead     __PACK__;   //(88:2)    SEQ     data need to be cut off in an acquisition line, in head direction
DHL.m_ushCutoffHead = fread(fid,1,'uint16');b = b + 2;
%    uint16_t     m_ushCutoffTail     __PACK__;   //(90:2)    SEQ     data need to be cut off in an acquisition line, in tail direction
DHL.m_ushCutoffTail = fread(fid,1,'uint16');b = b + 2;
%    uint16_t     m_ushROCenter       __PACK__;   //(92:2)    SEQ     kspace center index of readout
DHL.m_ushROCenter = fread(fid,1,'uint16');b = b + 2;
%    uint16_t     m_ushPECenter       __PACK__;   //(94:2)    SEQ     kspace center index of phase encoding
DHL.m_ushPECenter = fread(fid,1,'uint16');b = b + 2;
%    uint16_t     m_ushSPECenter      __PACK__;   //(96:2)    SEQ     kspace center index of secondary phase encoding
DHL.m_ushSPECenter = fread(fid,1,'uint16');b = b + 2;

%%%%%%%%%m_mySliceInfo
%    float        m_aflPosition[3]     __PACK__;  //( 0:12)   SEQ     slice position, 0:sag,1:cor,2:tra
DHL.m_aflPosition = fread(fid,[1 3],'float32');b = b + 12;
%    float        m_aflOrientation[4]  __PACK__;  //(12:16)   SEQ     slice orientation,0:sag,1:cor,2:tra (Normal Vector),3:inplane_rotate_angle (degree)
DHL.m_aflOrientation = fread(fid,[1 4],'float32');b = b + 16;

%%%%%%%%%% IripPara;
%     int16_t     m_int16[4];
%     int32_t     m_int32[2];
%     float       m_float[2];
%     double      m_double;
% fseek(fid,48,'cof');           b = b + 48;
DHL.m_IripPara = fread(fid,1,'double');b = b + 8;
fseek(fid,48 - 8*1,'cof'); b = b + 48 - 8*1;
%%%%%%%%%%
%    uint16_t     m_ushReserved[7]    __PACK__;   //(174:14)  N.A     make align to 192 bytes, reserved, DO NOT USE NOW
fseek(fid,14,'cof');          b = b + 14;
%    uint32_t     m_ulCRC             __PACK__;   //(188:4)   N.A     CRC check (not implement in s1)   
fseek(fid,4,'cof');         b = b + 4;

